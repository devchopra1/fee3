// src/spotifyService.js

import { refreshAccessToken, clearAllTokens } from './spotifyAuth'; 

// ðŸš¨ CRITICAL FIX: The CORRECT Spotify Web API Base URL (v1)
const API_BASE_URL = "https://api.spotify.com/v1"; 

/**
 * Maps a mood to Spotify Audio Feature targets (0.0 to 1.0).
 */
const moodMap = {
    'excited': { target_valence: 0.85, target_energy: 0.9, target_danceability: 0.7, min_tempo: 120 },
    'chill': { target_valence: 0.7, target_energy: 0.4, target_danceability: 0.5, max_tempo: 110 },
    'sad': { target_valence: 0.2, target_energy: 0.3, target_danceability: 0.4, max_tempo: 90 },
    'pumped': { target_valence: 0.5, target_energy: 0.95, target_tempo: 140, min_danceability: 0.6 },
};

/**
 * Generic API fetch wrapper that handles token expiry, refresh, and error codes.
 */
async function spotifyFetch(url, token, options = {}, retries = 0) {
    const expiry = localStorage.getItem('token_expiry');
    let currentToken = token;

    // 1. Check for Token Expiry before making the call
    if (expiry && Date.now() > parseInt(expiry) - 5000) {
        try {
            currentToken = await refreshAccessToken();
        } catch (e) {
            clearAllTokens();
            throw new Error("Session expired. Please log in again to renew permissions.");
        }
    }

    const defaultOptions = {
        method: 'GET',
        headers: {
            'Authorization': `Bearer ${currentToken}`,
            'Content-Type': 'application/json',
        },
    };
    const finalOptions = {
        ...defaultOptions,
        ...options,
        headers: { ...defaultOptions.headers, ...options.headers }
    };

    // Concatenate the correct base URL with the endpoint path
    const response = await fetch(`${API_BASE_URL}${url}`, finalOptions);

    // 2. Handle 401 Unauthorized (token just expired)
    if (response.status === 401 && retries === 0) {
        try {
            const newToken = await refreshAccessToken();
            // Retry the original call with the new token
            return spotifyFetch(url, newToken, options, 1); 
        } catch (e) {
            clearAllTokens();
            throw new Error("Session expired. Please log in.");
        }
    }
    
    // 3. Handle 403 Forbidden (Missing Scopes)
    if (response.status === 403) {
        clearAllTokens();
        throw new Error("Permission Denied (403). You must log in again and agree to **all** permissions to create playlists.");
    }

    if (!response.ok) {
        // Log error detail for advanced debugging
        const errorDetail = await response.text();
        console.error(`Spotify API call failed: ${response.status} for ${url}`, errorDetail);
        throw new Error(`Spotify API Error: ${response.statusText}. Code: ${response.status}`);
    }

    if (response.status === 204) return {}; 
    
    return response.json();
}


export async function getCurrentUserId(token) {
    const userProfile = await spotifyFetch('/me', token);
    return userProfile.id;
}

export async function getRecommendedTracks(token, mood) {
    const targets = moodMap[mood.toLowerCase()];

    if (!targets) {
        throw new Error(`Invalid mood: ${mood}`);
    }

    const queryParams = new URLSearchParams({
        limit: 25, 
        seed_genres: 'pop,rock,edm,chill', 
        ...targets,
    });

    const data = await spotifyFetch(`/recommendations?${queryParams.toString()}`, token);
    
    if (data.tracks.length === 0) {
        throw new Error("Spotify returned zero tracks for this mood. Try a different mood.");
    }

    return data.tracks.map(track => track.uri);
}

export async function createNewPlaylist(token, userId, mood) {
    const moodTitle = mood.charAt(0).toUpperCase() + mood.slice(1);
    const playlistName = `MoodPlayl.ist: ${moodTitle} Vibe`;
    
    const body = {
        name: playlistName,
        description: `A playlist generated by MoodPlayl.ist for a ${moodTitle} mood.`,
        public: true 
    };

    const playlist = await spotifyFetch(`/users/${userId}/playlists`, token, {
        method: 'POST',
        body: JSON.stringify(body),
    });

    return { id: playlist.id, url: playlist.external_urls.spotify };
}

export async function addTracksToPlaylist(token, playlistId, trackUris) {
    const body = {
        uris: trackUris,
    };

    await spotifyFetch(`/playlists/${playlistId}/tracks`, token, {
        method: 'POST',
        body: JSON.stringify(body),
    });
}

/**
 * Orchestrates the full playlist creation flow.
 */
export async function generatePlaylist(token, mood) {
    const userId = await getCurrentUserId(token);
    const trackUris = await getRecommendedTracks(token, mood);
    const { id: playlistId, url: playlistUrl } = await createNewPlaylist(token, userId, mood); 
    await addTracksToPlaylist(token, playlistId, trackUris);
    
    return {
        name: `MoodPlayl.ist: ${mood.charAt(0).toUpperCase() + mood.slice(1)} Vibe`,
        url: playlistUrl,
        tracks: trackUris.length,
    };
}