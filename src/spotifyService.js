// src/spotifyService.js

import { refreshAccessToken, clearAllTokens } from './spotifyAuth'; 

// ðŸš¨ FIX: THIS IS THE REAL SPOTIFY API URL
const API_BASE_URL = "https://api.spotify.com/v1"; 

const moodMap = {
    'excited': { target_valence: 0.85, target_energy: 0.9, target_danceability: 0.7, min_tempo: 120 },
    'chill': { target_valence: 0.7, target_energy: 0.4, target_danceability: 0.5, max_tempo: 110 },
    'sad': { target_valence: 0.2, target_energy: 0.3, target_danceability: 0.4, max_tempo: 90 },
    'pumped': { target_valence: 0.5, target_energy: 0.95, target_tempo: 140, min_danceability: 0.6 },
};

async function spotifyFetch(url, token, options = {}, retries = 0) {
    const expiry = localStorage.getItem('token_expiry');
    let currentToken = token;

    // Check for expiry
    if (expiry && Date.now() > parseInt(expiry) - 5000) {
        try {
            currentToken = await refreshAccessToken();
        } catch (e) {
            clearAllTokens();
            throw new Error("Session expired. Please log in again.");
        }
    }

    const defaultOptions = {
        method: 'GET',
        headers: {
            'Authorization': `Bearer ${currentToken}`,
            'Content-Type': 'application/json',
        },
    };
    const finalOptions = {
        ...defaultOptions,
        ...options,
        headers: { ...defaultOptions.headers, ...options.headers }
    };

    // Request to the REAL Spotify API
    const response = await fetch(`${API_BASE_URL}${url}`, finalOptions);

    // Handle 401 (Token Expired)
    if (response.status === 401 && retries === 0) {
        try {
            const newToken = await refreshAccessToken();
            return spotifyFetch(url, newToken, options, 1); 
        } catch (e) {
            clearAllTokens();
            throw new Error("Session expired. Please log in.");
        }
    }
    
    // Handle 403 (Forbidden / Scopes)
    if (response.status === 403) {
        clearAllTokens();
        throw new Error("Permission Denied (403). Log in again and click 'Agree' to all permissions.");
    }

    if (!response.ok) {
        const errorDetail = await response.text();
        console.error(`Spotify API Error: ${response.status}`, errorDetail);
        throw new Error(`Spotify API Error: ${response.status}`);
    }

    if (response.status === 204) return {}; 
    return response.json();
}

export async function getCurrentUserId(token) {
    const userProfile = await spotifyFetch('/me', token);
    return userProfile.id;
}

export async function getRecommendedTracks(token, mood) {
    const targets = moodMap[mood.toLowerCase()];
    if (!targets) throw new Error(`Invalid mood: ${mood}`);

    const queryParams = new URLSearchParams({
        limit: 25, 
        seed_genres: 'pop,rock,edm,chill', 
        ...targets,
    });

    const data = await spotifyFetch(`/recommendations?${queryParams.toString()}`, token);
    
    if (!data.tracks || data.tracks.length === 0) {
        throw new Error("No tracks found for this mood.");
    }

    return data.tracks.map(track => track.uri);
}

export async function createNewPlaylist(token, userId, mood) {
    const moodTitle = mood.charAt(0).toUpperCase() + mood.slice(1);
    const body = {
        name: `MoodPlayl.ist: ${moodTitle} Vibe`,
        description: `Generated by MoodPlayl.ist`,
        public: true 
    };

    const playlist = await spotifyFetch(`/users/${userId}/playlists`, token, {
        method: 'POST',
        body: JSON.stringify(body),
    });

    return { id: playlist.id, url: playlist.external_urls.spotify };
}

export async function addTracksToPlaylist(token, playlistId, trackUris) {
    await spotifyFetch(`/playlists/${playlistId}/tracks`, token, {
        method: 'POST',
        body: JSON.stringify({ uris: trackUris }),
    });
}

export async function generatePlaylist(token, mood) {
    const userId = await getCurrentUserId(token);
    const trackUris = await getRecommendedTracks(token, mood);
    const { id: playlistId, url: playlistUrl } = await createNewPlaylist(token, userId, mood); 
    await addTracksToPlaylist(token, playlistId, trackUris);
    
    return {
        name: `MoodPlayl.ist: ${mood.charAt(0).toUpperCase() + mood.slice(1)} Vibe`,
        url: playlistUrl,
        tracks: trackUris.length,
    };
}