// src/spotifyService.js

import { refreshAccessToken } from './spotifyAuth';

const API_BASE_URL = "https://api.spotify.com/v1";

/**
 * Maps a mood to Spotify Audio Feature targets (0.0 to 1.0) for the /recommendations endpoint.
 * Audio Features: valence (positivity), energy, danceability, tempo.
 */
const moodMap = {
    // High Valence (Happy) & High Energy (Excited)
    'excited': { target_valence: 0.85, target_energy: 0.9, target_danceability: 0.7, min_tempo: 120 },
    // Mid/High Valence & Low/Mid Energy (Relaxed)
    'chill': { target_valence: 0.7, target_energy: 0.4, target_danceability: 0.5, max_tempo: 110 },
    // Low Valence (Sad) & Low Energy (Melancholy)
    'sad': { target_valence: 0.2, target_energy: 0.3, target_danceability: 0.4, max_tempo: 90 },
    // Mid Valence & High Energy (Workout/Aggressive)
    'pumped': { target_valence: 0.5, target_energy: 0.95, target_tempo: 140, min_danceability: 0.6 },
};

/**
 * Generic API fetch wrapper that handles token expiry and retries (Source 1.1).
 */
async function spotifyFetch(url, token, options = {}, retries = 0) {
    const expiry = localStorage.getItem('token_expiry');
    let currentToken = token;

    // 1. Check if token is expired (allow 5 second buffer)
    if (expiry && Date.now() > parseInt(expiry) - 5000) {
        try {
            currentToken = await refreshAccessToken();
        } catch (e) {
            throw new Error("Authentication failed. Please log in again.");
        }
    }

    const defaultOptions = {
        method: 'GET',
        headers: {
            'Authorization': `Bearer ${currentToken}`,
            'Content-Type': 'application/json',
        },
    };
    const finalOptions = {
        ...defaultOptions,
        ...options,
        headers: { ...defaultOptions.headers, ...options.headers }
    };

    const response = await fetch(`${API_BASE_URL}${url}`, finalOptions);

    // 2. Handle 401 Unauthorized errors by retrying once after refresh
    if (response.status === 401 && retries === 0) {
        try {
            const newToken = await refreshAccessToken();
            // Retry the original call with the new token
            return spotifyFetch(url, newToken, options, 1); 
        } catch (e) {
            throw new Error("Session expired. Please log in.");
        }
    }

    if (!response.ok) {
        // Log the detailed error from Spotify's API for debugging
        const errorDetail = await response.text();
        console.error(`Spotify API call failed: ${response.status} for ${url}`, errorDetail);
        throw new Error(`Spotify API Error: ${response.statusText}. Code: ${response.status}`);
    }

    if (response.status === 204) return {}; 
    
    return response.json();
}

// --- CORE PLAYLIST FUNCTIONS ---

export async function getCurrentUserId(token) {
    // Endpoint: GET /v1/me
    const userProfile = await spotifyFetch('/me', token);
    return userProfile.id;
}

export async function getRecommendedTracks(token, mood) {
    const targets = moodMap[mood.toLowerCase()];

    if (!targets) {
        throw new Error(`Invalid mood: ${mood}`);
    }

    // Endpoint: GET /v1/recommendations
    const queryParams = new URLSearchParams({
        limit: 25, 
        // Use general genre seeds as a starting point (Source 2.5)
        seed_genres: 'pop,rock,edm,chill', 
        ...targets,
    });

    const data = await spotifyFetch(`/recommendations?${queryParams.toString()}`, token);
    
    if (data.tracks.length === 0) {
        throw new Error("Spotify returned zero tracks for this mood. Try a different mood.");
    }

    return data.tracks.map(track => track.uri); // Returns an array of Spotify URIs
}

export async function createNewPlaylist(token, userId, mood) {
    const moodTitle = mood.charAt(0).toUpperCase() + mood.slice(1);
    const playlistName = `MoodPlayl.ist: ${moodTitle} Vibe`;
    
    const body = {
        name: playlistName,
        description: `A playlist generated by MoodPlayl.ist for a ${moodTitle} mood.`,
        public: true // Public by default (Source 3.1)
    };

    // Endpoint: POST /v1/users/{user_id}/playlists
    const playlist = await spotifyFetch(`/users/${userId}/playlists`, token, {
        method: 'POST',
        body: JSON.stringify(body),
    });

    return { id: playlist.id, url: playlist.external_urls.spotify };
}

export async function addTracksToPlaylist(token, playlistId, trackUris) {
    const body = {
        uris: trackUris,
        // If position is omitted, items are appended to the end (Source 3.2)
    };

    // Endpoint: POST /v1/playlists/{playlist_id}/tracks
    await spotifyFetch(`/playlists/${playlistId}/tracks`, token, {
        method: 'POST',
        body: JSON.stringify(body),
    });
}

/**
 * Orchestrates the full playlist creation flow.
 */
export async function generatePlaylist(token, mood) {
    const userId = await getCurrentUserId(token);
    const trackUris = await getRecommendedTracks(token, mood);
    const { id: playlistId, url: playlistUrl } = await createNewPlaylist(token, userId, mood);
    
    await addTracksToPlaylist(token, playlistId, trackUris);
    
    return {
        name: `MoodPlayl.ist: ${mood.charAt(0).toUpperCase() + mood.slice(1)} Vibe`,
        url: playlistUrl,
        tracks: trackUris.length,
    };
}